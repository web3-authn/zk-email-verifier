use std::{env, fs, path::Path};

use ark_bn254::{Bn254, Fq, Fq2, G1Affine, G2Affine};
use ark_groth16::{prepare_verifying_key, VerifyingKey};
use core::str::FromStr;
use serde::Deserialize;

/// Minimal shape of snarkjs verification_key.json that we care about.
#[derive(Deserialize)]
struct VerificationKey {
    vk_alpha_1: [String; 3],
    vk_beta_2: [[String; 2]; 3],
    vk_gamma_2: [[String; 2]; 3],
    vk_delta_2: [[String; 2]; 3],
    #[serde(rename = "IC")]
    ic: Vec<[String; 3]>,
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!(
            "Usage: vk_to_rust <verification_key.json> <output_vk_rs_path>\n\
             Example: vk_to_rust ../build/verification_key.json ../zk-email-verifier-contract/src/vk.rs"
        );
        std::process::exit(1);
    }

    let vkey_path = &args[1];
    let out_path = &args[2];

    let vkey_json = fs::read_to_string(vkey_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", vkey_path, e));

    let vkey: VerificationKey =
        serde_json::from_str(&vkey_json).expect("Failed to parse verification_key.json");

    // Validate the vkey by constructing an Arkworks VerifyingKey and preparing it.
    let vk_ark = build_verifying_key(&vkey);
    let _pvk = prepare_verifying_key(&vk_ark);
    println!("Verification key parsed and prepared successfully with Arkworks.");

    let out_dir = Path::new(out_path).parent().expect("invalid output path");
    fs::create_dir_all(out_dir).expect("failed to create output directory");

    // Build gamma_abc_g1 entries as a single string to embed in the template.
    let gamma_abc_entries = vkey
        .ic
        .iter()
        .map(|ic| {
            format!(
                "        G1Affine::new_unchecked(\n            Fq::from_str(\"{}\").unwrap(),\n            Fq::from_str(\"{}\").unwrap(),\n        ),\n",
                ic[0], ic[1]
            )
        })
        .collect::<String>();

    let out = format!(
        "// This file is @generated by vk_to_rust; do not edit manually.
use core::str::FromStr;
use ark_bn254::{{Bn254, Fq, Fq2, G1Affine, G2Affine, Fr}};
use ark_groth16::VerifyingKey;

pub fn verifying_key() -> VerifyingKey<Bn254> {{
    let alpha_g1 = G1Affine::new_unchecked(
        Fq::from_str(\"{alpha_x}\").unwrap(),
        Fq::from_str(\"{alpha_y}\").unwrap(),
    );

    let beta_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(\"{beta_x0}\").unwrap(),
            Fq::from_str(\"{beta_x1}\").unwrap(),
        ),
        Fq2::new(
            Fq::from_str(\"{beta_y0}\").unwrap(),
            Fq::from_str(\"{beta_y1}\").unwrap(),
        ),
    );

    let gamma_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(\"{gamma_x0}\").unwrap(),
            Fq::from_str(\"{gamma_x1}\").unwrap(),
        ),
        Fq2::new(
            Fq::from_str(\"{gamma_y0}\").unwrap(),
            Fq::from_str(\"{gamma_y1}\").unwrap(),
        ),
    );

    let delta_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(\"{delta_x0}\").unwrap(),
            Fq::from_str(\"{delta_x1}\").unwrap(),
        ),
        Fq2::new(
            Fq::from_str(\"{delta_y0}\").unwrap(),
            Fq::from_str(\"{delta_y1}\").unwrap(),
        ),
    );

    let gamma_abc_g1: Vec<G1Affine> = vec![
        {gamma_abc_entries}
    ];

    VerifyingKey::<Bn254> {{
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    }}
}}
",
        alpha_x = vkey.vk_alpha_1[0],
        alpha_y = vkey.vk_alpha_1[1],
        beta_x0 = vkey.vk_beta_2[0][0],
        beta_x1 = vkey.vk_beta_2[0][1],
        beta_y0 = vkey.vk_beta_2[1][0],
        beta_y1 = vkey.vk_beta_2[1][1],
        gamma_x0 = vkey.vk_gamma_2[0][0],
        gamma_x1 = vkey.vk_gamma_2[0][1],
        gamma_y0 = vkey.vk_gamma_2[1][0],
        gamma_y1 = vkey.vk_gamma_2[1][1],
        delta_x0 = vkey.vk_delta_2[0][0],
        delta_x1 = vkey.vk_delta_2[0][1],
        delta_y0 = vkey.vk_delta_2[1][0],
        delta_y1 = vkey.vk_delta_2[1][1],
        gamma_abc_entries = gamma_abc_entries,
    );

    fs::write(out_path, out).unwrap_or_else(|e| {
        panic!("Failed to write {}: {}", out_path, e);
    });
}

fn build_verifying_key(v: &VerificationKey) -> VerifyingKey<Bn254> {
    let alpha_g1 = G1Affine::new_unchecked(
        Fq::from_str(&v.vk_alpha_1[0]).unwrap(),
        Fq::from_str(&v.vk_alpha_1[1]).unwrap(),
    );

    let beta_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(&v.vk_beta_2[0][0]).unwrap(),
            Fq::from_str(&v.vk_beta_2[0][1]).unwrap(),
        ),
        Fq2::new(
            Fq::from_str(&v.vk_beta_2[1][0]).unwrap(),
            Fq::from_str(&v.vk_beta_2[1][1]).unwrap(),
        ),
    );

    let gamma_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(&v.vk_gamma_2[0][0]).unwrap(),
            Fq::from_str(&v.vk_gamma_2[0][1]).unwrap(),
        ),
        Fq2::new(
            Fq::from_str(&v.vk_gamma_2[1][0]).unwrap(),
            Fq::from_str(&v.vk_gamma_2[1][1]).unwrap(),
        ),
    );

    let delta_g2 = G2Affine::new_unchecked(
        Fq2::new(
            Fq::from_str(&v.vk_delta_2[0][0]).unwrap(),
            Fq::from_str(&v.vk_delta_2[0][1]).unwrap(),
        ),
        Fq2::new(
            Fq::from_str(&v.vk_delta_2[1][0]).unwrap(),
            Fq::from_str(&v.vk_delta_2[1][1]).unwrap(),
        ),
    );

    let gamma_abc_g1: Vec<G1Affine> = v
        .ic
        .iter()
        .map(|ic| {
            G1Affine::new_unchecked(
                Fq::from_str(&ic[0]).unwrap(),
                Fq::from_str(&ic[1]).unwrap(),
            )
        })
        .collect();

    VerifyingKey::<Bn254> { alpha_g1, beta_g2, gamma_g2, delta_g2, gamma_abc_g1 }
}
